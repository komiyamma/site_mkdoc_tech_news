# 第42章：配列操作のイミュータブルな書き方（スプレッド構文など）

前章で「`push` はダメ！ `filter` や `map` を使おう」と言いました。
この章では、もう少し複雑なパターン（オブジェクトの配列など）を含めて、
**「イミュータブル（不変）な書き方」** を完全にマスターします 🥋

---

## 1. なぜ「イミュータブル」じゃないとダメ？ 🧐

理由は大きく2つあります。

1. **Reactの再レンダリング検知のため** 🕵️‍♀️
   Reactは高速化のために、「変数の参照先（メモリアドレス）が変わったか？」だけを見て変更を検知します（浅い比較）。
   中身を書き換えても箱（配列）が同じだと「変更なし」と判断されます。
   新しい箱（新しい配列）を作って渡すことで、「あ、箱が変わった！中身も変わったんだな！」と気づかせます。

2. **予期せぬバグを防ぐため** 🛡️
   「配列を渡した先のコンポーネントで勝手に中身を書き換えられちゃった…」
   みたいな事故がなくなります。データが変わるときは必ず「新しいデータを作る」ので、データの流れが追いやすくなります。

---

## 2. オブジェクトの配列の場合 📦📦

実務では `["りんご", "みかん"]` みたいな単純な配列より、
`[{ id: 1, name: "りんご" }, ...]` みたいな **オブジェクトの配列** を扱うことがほとんどです。

ここでも基本は同じですが、**「オブジェクトの中身」を更新するとき** に注意が必要です。

### ❌ ダメな例

```tsx
const updateName = (id, newName) => {
  setUsers(users.map(user => {
    if (user.id === id) {
      user.name = newName; // 😱 中身を直接書き換えちゃってる！
      return user;
    }
    return user;
  }));
};
```
これだと、配列自体は新しくなっても、中のオブジェクトが古いまま書き換えられているので、細かいバグの原因になります。

### ⭕️ 正しい例（ネストしたスプレッド）

```tsx
const updateName = (id, newName) => {
  setUsers(users.map(user => {
    if (user.id === id) {
      // 古いuserを展開して、nameだけ上書きした「新しいオブジェクト」を返す
      return { ...user, name: newName }; 
    }
    return user;
  }));
};
```

**「配列も新しくするし、変更するオブジェクトも新しくする」**
これが鉄則です ✨

---

## 3. よく使うイミュータブル操作レシピ 🍳

これだけ覚えておけばだいたい戦えます！

### ① 先頭に追加 (`unshift` の代わり)

```tsx
setList([newItem, ...list]);
```

### ② 指定位置に挿入 (`splice` の代わり)

```tsx
// index の位置に newItem を入れたい
setList([
  ...list.slice(0, index),
  newItem,
  ...list.slice(index)
]);
```
`slice` は元の配列を壊さずにコピーを返すので安全です 👍

### ③ 並び替え (`sort` の代わり)

`sort` や `reverse` は元の配列を破壊するので、一度コピーしてから行います。

```tsx
// ❌ list.sort(...) 
// ⭕️ [...list].sort(...)
setList([...list].sort((a, b) => a.id - b.id));
```
`[...list]` と書くことで、配列を浅くコピー（新しい箱に入れ替え）してからソートします。

---

## 4. 便利ライブラリ `Immer` (紹介だけ) 🐻

「スプレッド構文 `...` ばっかり書いてて、カッコが多くて見づらいよ〜！」
ネストが深くなると誰もがそう思います 😫

そんなとき、実務では **Immer (イマー)** というライブラリがよく使われます。
これを使うと、**「書き換えてるように書けるけど、裏で勝手にイミュータブルにしてくれる」** という魔法が使えます。

```tsx
// Immerを使うとこう書ける（イメージ）
setUsers(draft => {
  const user = draft.find(u => u.id === 1);
  if (user) user.name = "New Name"; // 普通に代入してOK！魔法！
});
```

初心者のうちは基本の書き方（スプレッド構文）をマスターすべきですが、
「辛くなったら便利な道具がある」と知っておくと心が楽になりますよ 🍀

---

## 5. まとめ 🌟

* Reactでは **イミュータブル（不変）** なデータ操作が絶対ルール。
* 理由は「再レンダリングの検知」と「バグ防止」。
* オブジェクトの配列を更新するときは、**中のオブジェクトもコピー(`...obj`)** して新しくする。
* `sort` などの破壊的メソッドは、`[...arr]` でコピーしてから使う。

次は、こうして作った配列データを画面にズラッと表示する
**「リストレンダリング (`map`)」** について学びます。
ここで `key` という大事な概念が出てきますよ 🗝️